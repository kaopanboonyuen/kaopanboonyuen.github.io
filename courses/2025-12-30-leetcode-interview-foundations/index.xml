<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode Interview Foundations | Teerapong Panboonyuen</title>
    <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/</link>
      <atom:link href="https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/index.xml" rel="self" type="application/rss+xml" />
    <description>LeetCode Interview Foundations</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â©2026 Kao Panboonyuen</copyright><lastBuildDate>Tue, 30 Dec 2025 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://kaopanboonyuen.github.io/media/icon_hueaa9297dc78a770d45cebdfb81bbca28_1203332_512x512_fill_lanczos_center_3.png</url>
      <title>LeetCode Interview Foundations</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/</link>
    </image>
    
    <item>
      <title>CS101-LC01 â€” What is LeetCode? (Why Everyone Uses It)</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc01-intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc01-intro/</guid>
      <description>&lt;p&gt;
  &lt;i class=&#34;fas fa-clock  pr-1 fa-fw&#34;&gt;&lt;/i&gt; ~30 minutes&lt;/p&gt;
&lt;h2 id=&#34;-why-this-chapter-matters&#34;&gt;ğŸ¯ Why This Chapter Matters&lt;/h2&gt;
&lt;p&gt;Before solving problems, you must understand &lt;strong&gt;why&lt;/strong&gt; you are solving them.&lt;/p&gt;
&lt;p&gt;LeetCode is not just a website.&lt;br&gt;
It is a &lt;strong&gt;thinking framework&lt;/strong&gt; used worldwide to evaluate engineers.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-what-is-leetcode&#34;&gt;ğŸ¤” What is LeetCode?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt; is an online platform for practicing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Algorithms&lt;/li&gt;
&lt;li&gt;Data Structures&lt;/li&gt;
&lt;li&gt;Logical problem solving&lt;/li&gt;
&lt;li&gt;Interview-style coding questions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Problems range from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beginner (arrays, loops)&lt;/li&gt;
&lt;li&gt;Intermediate (hash maps, trees)&lt;/li&gt;
&lt;li&gt;Advanced (DP, graphs, system thinking)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-who-uses-leetcode&#34;&gt;ğŸŒ Who Uses LeetCode?&lt;/h2&gt;
&lt;p&gt;LeetCode-style questions are used by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google&lt;/li&gt;
&lt;li&gt;Meta (Facebook)&lt;/li&gt;
&lt;li&gt;Amazon&lt;/li&gt;
&lt;li&gt;Microsoft&lt;/li&gt;
&lt;li&gt;Apple&lt;/li&gt;
&lt;li&gt;Netflix&lt;/li&gt;
&lt;li&gt;Startups &amp;amp; research labs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even if the interview is &lt;strong&gt;not on LeetCode&lt;/strong&gt;,&lt;br&gt;
the &lt;strong&gt;problem patterns are the same&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-what-leetcode-is-really-training&#34;&gt;ğŸ§  What LeetCode Is REALLY Training&lt;/h2&gt;
&lt;p&gt;LeetCode is NOT about memorizing code.&lt;/p&gt;
&lt;p&gt;It trains you to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Break big problems into smaller ones&lt;/li&gt;
&lt;li&gt;Recognize patterns&lt;/li&gt;
&lt;li&gt;Choose the right data structure&lt;/li&gt;
&lt;li&gt;Optimize time &amp;amp; memory&lt;/li&gt;
&lt;li&gt;Explain your reasoning clearly&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-what-interviewers-look-for&#34;&gt;ğŸ” What Interviewers Look For&lt;/h2&gt;
&lt;p&gt;Interviewers are evaluating &lt;strong&gt;how you think&lt;/strong&gt;, not just the final answer.&lt;/p&gt;
&lt;p&gt;They care about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clear understanding of the problem&lt;/li&gt;
&lt;li&gt;Logical step-by-step reasoning&lt;/li&gt;
&lt;li&gt;Clean, readable code&lt;/li&gt;
&lt;li&gt;Correct time complexity (Big-O)&lt;/li&gt;
&lt;li&gt;Ability to improve a slow solution&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interview-reality-check&#34;&gt;ğŸ§ª Interview Reality Check&lt;/h2&gt;
&lt;p&gt;You are usually expected to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Explain the problem in your own words&lt;/li&gt;
&lt;li&gt;Start with a simple (even slow) solution&lt;/li&gt;
&lt;li&gt;Analyze time complexity&lt;/li&gt;
&lt;li&gt;Improve it&lt;/li&gt;
&lt;li&gt;Communicate clearly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Perfect code â‰  Perfect interview&lt;br&gt;
Clear thinking = Pass&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-common-beginner-misunderstanding&#34;&gt;ğŸ§  Common Beginner Misunderstanding&lt;/h2&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Does LeetCode measure intelligence?&lt;/summary&gt;
  &lt;p&gt;âŒ No&lt;br&gt;
âœ… It measures &lt;strong&gt;problem-solving patterns&lt;/strong&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;Someone who practiced patterns will outperform&lt;br&gt;
someone who is â€œsmart but untrainedâ€.&lt;/p&gt;
&lt;p&gt;This is &lt;strong&gt;learnable&lt;/strong&gt;, not talent-based.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-examples-of-patterns-you-will-learn&#34;&gt;ğŸ§© Examples of Patterns You Will Learn&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Pattern&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Two pointers&lt;/td&gt;
&lt;td&gt;Palindrome check&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hash map&lt;/td&gt;
&lt;td&gt;Two Sum&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sliding window&lt;/td&gt;
&lt;td&gt;Subarray problems&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Prefix sum&lt;/td&gt;
&lt;td&gt;Range queries&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stack&lt;/td&gt;
&lt;td&gt;Valid parentheses&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BFS / DFS&lt;/td&gt;
&lt;td&gt;Tree &amp;amp; graph traversal&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Once you see the pattern,&lt;br&gt;
many problems feel &lt;strong&gt;similar&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-why-leetcode-is-used-in-exams&#34;&gt;ğŸ« Why LeetCode is Used in Exams&lt;/h2&gt;
&lt;p&gt;LeetCode-style questions test:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logic&lt;/li&gt;
&lt;li&gt;Edge cases&lt;/li&gt;
&lt;li&gt;Complexity awareness&lt;/li&gt;
&lt;li&gt;Coding discipline&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These skills apply to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Midterm / final exams&lt;/li&gt;
&lt;li&gt;Programming contests&lt;/li&gt;
&lt;li&gt;Research code&lt;/li&gt;
&lt;li&gt;Real-world software&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-how-to-use-leetcode-correctly&#34;&gt;ğŸ How to Use LeetCode Correctly&lt;/h2&gt;
&lt;p&gt;âŒ Wrong way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Copy solution&lt;/li&gt;
&lt;li&gt;Memorize code&lt;/li&gt;
&lt;li&gt;Skip explanation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;âœ… Right way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Understand the idea&lt;/li&gt;
&lt;li&gt;Rewrite in your own style&lt;/li&gt;
&lt;li&gt;Analyze complexity&lt;/li&gt;
&lt;li&gt;Explain out loud&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you can &lt;strong&gt;teach it&lt;/strong&gt;, you truly understand it.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-goal-of-this-course&#34;&gt;ğŸ¯ Goal of This Course&lt;/h2&gt;
&lt;p&gt;By the end of this course, you should be able to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Look at a problem&lt;/li&gt;
&lt;li&gt;Identify its pattern&lt;/li&gt;
&lt;li&gt;Choose the right approach&lt;/li&gt;
&lt;li&gt;Write clean, efficient code&lt;/li&gt;
&lt;li&gt;Explain your solution confidently&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That is exactly what interviewers want.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-message&#34;&gt;ğŸš€ Final Message&lt;/h2&gt;
&lt;p&gt;LeetCode is not a test of intelligence.&lt;br&gt;
It is training for &lt;strong&gt;structured thinking&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If you practice correctly,&lt;br&gt;
you will think like a software engineer.&lt;/p&gt;
&lt;p&gt;And that skill lasts a lifetime ğŸ’¡&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CS101-LC02 â€” Big-O Intuition</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc02-big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc02-big-o/</guid>
      <description>&lt;h2 id=&#34;-why-big-o-matters&#34;&gt;ğŸ¯ Why Big-O Matters&lt;/h2&gt;
&lt;p&gt;Big-O is &lt;strong&gt;NOT&lt;/strong&gt; about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exact seconds&lt;/li&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Programming language&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Big-O is about &lt;strong&gt;scaling&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;â“ If input becomes 10Ã— bigger, how much slower will your program be?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thatâ€™s what interviewers, professors, and engineers care about.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-simple-definition&#34;&gt;ğŸ§  Simple Definition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Big-O describes how an algorithmâ€™s runtime or memory grows as input size increases.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We focus on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Worst-case behavior&lt;/li&gt;
&lt;li&gt;Growth trend&lt;/li&gt;
&lt;li&gt;Ignoring constants&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-real-world-analogy&#34;&gt;ğŸ• Real-World Analogy&lt;/h2&gt;
&lt;p&gt;Imagine finding your name in a list of students.&lt;/p&gt;
&lt;h3 id=&#34;case-1-you-know-your-seat-number&#34;&gt;Case 1: You know your seat number&lt;/h3&gt;
&lt;p&gt;â†’ You check once&lt;br&gt;
âœ… Constant time â†’ &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;case-2-names-listed-randomly&#34;&gt;Case 2: Names listed randomly&lt;/h3&gt;
&lt;p&gt;â†’ You scan one by one&lt;br&gt;
ğŸ“ˆ Linear â†’ &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;case-3-names-sorted-alphabetically&#34;&gt;Case 3: Names sorted alphabetically&lt;/h3&gt;
&lt;p&gt;â†’ You keep halving the list&lt;br&gt;
âš¡ Fast â†’ &lt;strong&gt;O(log n)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-common-big-o-classes-must-memorize&#34;&gt;ğŸ“Š Common Big-O Classes (Must Memorize)&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Big-O&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Real Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;Constant&lt;/td&gt;
&lt;td&gt;Always same time&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;td&gt;Logarithmic&lt;/td&gt;
&lt;td&gt;Divide &amp;amp; conquer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;Linear&lt;/td&gt;
&lt;td&gt;Scan once&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O(n log n)&lt;/td&gt;
&lt;td&gt;Log-linear&lt;/td&gt;
&lt;td&gt;Efficient sorting&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O(nÂ²)&lt;/td&gt;
&lt;td&gt;Quadratic&lt;/td&gt;
&lt;td&gt;Nested loops&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O(2â¿)&lt;/td&gt;
&lt;td&gt;Exponential&lt;/td&gt;
&lt;td&gt;Very slow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-o1--constant-time&#34;&gt;âš™ï¸ O(1) â€” Constant Time&lt;/h2&gt;
&lt;p&gt;Time does &lt;strong&gt;not&lt;/strong&gt; depend on input size.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_first(arr):
    return arr[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No matter how big &lt;code&gt;arr&lt;/code&gt; is â†’ still 1 step.&lt;/p&gt;
&lt;p&gt;ğŸ“Œ Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Array index access&lt;/li&gt;
&lt;li&gt;Hash map lookup&lt;/li&gt;
&lt;li&gt;Stack push/pop&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-on--linear-time&#34;&gt;ğŸ“ˆ O(n) â€” Linear Time&lt;/h2&gt;
&lt;p&gt;Runtime grows &lt;strong&gt;directly&lt;/strong&gt; with input size.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(arr, x):
    for v in arr:
        if v == x:
            return True
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If input doubles â†’ time doubles.&lt;/p&gt;
&lt;p&gt;ğŸ“Œ Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Counting frequency&lt;/li&gt;
&lt;li&gt;Finding max/min&lt;/li&gt;
&lt;li&gt;Scanning data&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-olog-n--logarithmic-time&#34;&gt;âš¡ O(log n) â€” Logarithmic Time&lt;/h2&gt;
&lt;p&gt;Each step cuts the problem in half.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(arr, x):
    l, r = 0, len(arr) - 1
    while l &amp;lt;= r:
        mid = (l + r) // 2
        if arr[mid] == x:
            return True
        elif arr[mid] &amp;lt; x:
            l = mid + 1
        else:
            r = mid - 1
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even for &lt;strong&gt;1 million elements&lt;/strong&gt;, only ~20 steps!&lt;/p&gt;
&lt;p&gt;ğŸ“Œ Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary search&lt;/li&gt;
&lt;li&gt;Tree traversal (balanced)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-on-log-n--efficient-algorithms&#34;&gt;ğŸ§  O(n log n) â€” Efficient Algorithms&lt;/h2&gt;
&lt;p&gt;Often comes from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Divide problem&lt;/li&gt;
&lt;li&gt;Solve subproblems&lt;/li&gt;
&lt;li&gt;Combine results&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sorted(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python uses &lt;strong&gt;Timsort&lt;/strong&gt; â†’ &lt;code&gt;O(n log n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ğŸ“Œ Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Merge sort&lt;/li&gt;
&lt;li&gt;Quick sort (average case)&lt;/li&gt;
&lt;li&gt;Heap sort&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-on--quadratic-time&#34;&gt;ğŸš¨ O(nÂ²) â€” Quadratic Time&lt;/h2&gt;
&lt;p&gt;Usually caused by &lt;strong&gt;nested loops&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(n):
    for j in range(n):
        do_something()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;n = 10,000&lt;/code&gt;
â†’ &lt;strong&gt;100 million operations&lt;/strong&gt; ğŸ˜±&lt;/p&gt;
&lt;p&gt;ğŸ“Œ Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pair comparisons&lt;/li&gt;
&lt;li&gt;Brute-force two sum&lt;/li&gt;
&lt;li&gt;Duplicate detection (naive)&lt;/li&gt;
&lt;/ul&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Nested loops usually mean?&lt;/summary&gt;
  &lt;p&gt;O(nÂ²)&lt;/p&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-why-on-is-dangerous&#34;&gt;ğŸ”¥ Why O(nÂ²) Is Dangerous&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;Operations&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1,000&lt;/td&gt;
&lt;td&gt;1,000,000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10,000&lt;/td&gt;
&lt;td&gt;100,000,000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This is why LeetCode &lt;strong&gt;TLE (Time Limit Exceeded)&lt;/strong&gt; happens.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-exam-style-questions&#34;&gt;ğŸ§ª Exam-Style Questions&lt;/h2&gt;
&lt;h3 id=&#34;q1&#34;&gt;Q1&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in arr:
    print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;âœ… &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;q2&#34;&gt;Q2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(n):
    for j in range(i):
        print(i, j)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;âœ… &lt;strong&gt;O(nÂ²)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;q3&#34;&gt;Q3&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 1
while i &amp;lt; n:
    i *= 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;âœ… &lt;strong&gt;O(log n)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-space-complexity-also-important&#34;&gt;ğŸ§  Space Complexity (Also Important)&lt;/h2&gt;
&lt;p&gt;Big-O also applies to &lt;strong&gt;memory usage&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;seen = set()
for x in arr:
    seen.add(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n)&lt;/li&gt;
&lt;li&gt;Space: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interviewers love this question:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;â€œCan you trade space for time?â€&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-real-world-engineering-insight&#34;&gt;ğŸ¯ Real-World Engineering Insight&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Situation&lt;/th&gt;
&lt;th&gt;Preferred&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Small data&lt;/td&gt;
&lt;td&gt;Simple code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Large data&lt;/td&gt;
&lt;td&gt;Better Big-O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Real-time system&lt;/td&gt;
&lt;td&gt;Predictable complexity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AI pipelines&lt;/td&gt;
&lt;td&gt;Vectorized / O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-golden-interview-rule&#34;&gt;ğŸ Golden Interview Rule&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;First make it work.
Then make it fast.
Then explain why.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you can &lt;strong&gt;explain Big-O clearly&lt;/strong&gt;, you already sound like a professional.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-takeaway&#34;&gt;ğŸ‰ Final Takeaway&lt;/h2&gt;
&lt;p&gt;Big-O is not math.
Big-O is &lt;strong&gt;thinking about scale&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Once you see it everywhere:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LeetCode becomes easier&lt;/li&gt;
&lt;li&gt;Code becomes cleaner&lt;/li&gt;
&lt;li&gt;Interviews become calmer ğŸ˜„&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Youâ€™re officially past beginner level ğŸš€&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CS101-LC03 â€” Python for Interviews</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc03-python-recap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc03-python-recap/</guid>
      <description>&lt;h2 id=&#34;-why-python-matters-in-interviews&#34;&gt;ğŸ¯ Why Python Matters in Interviews&lt;/h2&gt;
&lt;p&gt;Python is not just a language.&lt;br&gt;
It is a &lt;strong&gt;thinking tool&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Interviewers use Python to test:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clarity of thought&lt;/li&gt;
&lt;li&gt;Data structure mastery&lt;/li&gt;
&lt;li&gt;Algorithmic intuition&lt;/li&gt;
&lt;li&gt;Code readability&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-core-python-philosophy&#34;&gt;ğŸ§  Core Python Philosophy&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Simple is better than complex.&lt;br&gt;
Readability counts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If your code is easy to read, it is easy to debug and scale.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-iteration-patterns-fundamental&#34;&gt;ğŸ” Iteration Patterns (Fundamental)&lt;/h2&gt;
&lt;h3 id=&#34;looping-over-values&#34;&gt;Looping Over Values&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in arr:
    print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;looping-with-index&#34;&gt;Looping With Index&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i, x in enumerate(arr):
    print(i, x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;looping-in-reverse&#34;&gt;Looping in Reverse&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in reversed(arr):
    print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-containers-in-python&#34;&gt;ğŸ§º Containers in Python&lt;/h2&gt;
&lt;h3 id=&#34;list-ordered-mutable&#34;&gt;List (Ordered, Mutable)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [1, 2, 3]
nums.append(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Order matters&lt;/li&gt;
&lt;li&gt;Frequent appends&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;tuple-ordered-immutable&#34;&gt;Tuple (Ordered, Immutable)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;point = (3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data should not change&lt;/li&gt;
&lt;li&gt;Hashable keys&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;set-unique-elements&#34;&gt;Set (Unique Elements)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;seen = set()
seen.add(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deduplication&lt;/li&gt;
&lt;li&gt;Fast membership test&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;â±ï¸ Average lookup: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dictionary-key--value&#34;&gt;Dictionary (Key â†’ Value)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;freq = {}
for x in arr:
    freq[x] = freq.get(x, 0) + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Counting&lt;/li&gt;
&lt;li&gt;Mapping&lt;/li&gt;
&lt;li&gt;Fast lookup&lt;/li&gt;
&lt;/ul&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Why dictionaries are powerful?&lt;/summary&gt;
  &lt;p&gt;They use hash tables, giving &lt;strong&gt;O(1)&lt;/strong&gt; average access time.&lt;/p&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-searching-patterns&#34;&gt;ğŸ” Searching Patterns&lt;/h2&gt;
&lt;h3 id=&#34;linear-search&#34;&gt;Linear Search&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(arr, target):
    for x in arr:
        if x == target:
            return True
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(n)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;binary-search-sorted-array&#34;&gt;Binary Search (Sorted Array)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(arr, target):
    l, r = 0, len(arr) - 1

    while l &amp;lt;= r:
        mid = (l + r) // 2
        if arr[mid] == target:
            return True
        elif arr[mid] &amp;lt; target:
            l = mid + 1
        else:
            r = mid - 1

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(log n)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-vector-operations-ai-foundation&#34;&gt;ğŸ§® Vector Operations (AI Foundation)&lt;/h2&gt;
&lt;h3 id=&#34;vector-addition&#34;&gt;Vector Addition&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add_vectors(a, b):
    return [a[i] + b[i] for i in range(len(a))]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dot-product&#34;&gt;Dot Product&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dot(a, b):
    return sum(a[i] * b[i] for i in range(len(a)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Neural networks&lt;/li&gt;
&lt;li&gt;Similarity&lt;/li&gt;
&lt;li&gt;Attention&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-matrix-basics-2d-lists&#34;&gt;ğŸ§± Matrix Basics (2D Lists)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;matrix = [
    [1, 2, 3],
    [4, 5, 6]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;matrix-traversal&#34;&gt;Matrix Traversal&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for row in matrix:
    for val in row:
        print(val)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;matrix-multiplication-interview-classic&#34;&gt;Matrix Multiplication (Interview Classic)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def matmul(A, B):
    result = [[0]*len(B[0]) for _ in range(len(A))]

    for i in range(len(A)):
        for j in range(len(B[0])):
            for k in range(len(B)):
                result[i][j] += A[i][k] * B[k][j]

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(nÂ³)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-functions--clean-design&#34;&gt;ğŸ§  Functions &amp;amp; Clean Design&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def square(x: int) -&amp;gt; int:
    return x * x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why types help:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clarity&lt;/li&gt;
&lt;li&gt;Debugging&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-classes--objects-very-important&#34;&gt;ğŸ§± Classes &amp;amp; Objects (VERY IMPORTANT)&lt;/h2&gt;
&lt;h3 id=&#34;defining-a-class&#34;&gt;Defining a Class&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Vector:
    def __init__(self, values):
        self.values = values

    def dot(self, other):
        return sum(a*b for a, b in zip(self.values, other.values))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;using-the-class&#34;&gt;Using the Class&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;v1 = Vector([1, 2, 3])
v2 = Vector([4, 5, 6])
print(v1.dot(v2))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-inheritance-interview-favorite&#34;&gt;ğŸ§¬ Inheritance (Interview Favorite)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Matrix(Vector):
    def shape(self):
        return (len(self.values), len(self.values[0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why inheritance matters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code reuse&lt;/li&gt;
&lt;li&gt;Abstraction&lt;/li&gt;
&lt;li&gt;Design thinking&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-pythonic-tricks-interviewers-love&#34;&gt;ğŸ§  Pythonic Tricks Interviewers Love&lt;/h2&gt;
&lt;h3 id=&#34;list-comprehension&#34;&gt;List Comprehension&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;squares = [x*x for x in range(10)]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dictionary-comprehension&#34;&gt;Dictionary Comprehension&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;freq = {x: arr.count(x) for x in arr}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;any--all&#34;&gt;Any / All&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;any(x &amp;gt; 0 for x in arr)
all(x &amp;gt; 0 for x in arr)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-common-interview-mistakes&#34;&gt;ğŸš¨ Common Interview Mistakes&lt;/h2&gt;
&lt;p&gt;âŒ Overcomplicating
âŒ Ignoring edge cases
âŒ Forgetting time complexity
âŒ Writing unreadable code&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-interview-advice&#34;&gt;ğŸ Final Interview Advice&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Python interviews are not about syntax.
They are about &lt;strong&gt;how you think&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you master:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Containers&lt;/li&gt;
&lt;li&gt;Loops&lt;/li&gt;
&lt;li&gt;Functions&lt;/li&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Vectors &amp;amp; matrices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You are &lt;strong&gt;interview-ready&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-congratulations&#34;&gt;ğŸ‰ Congratulations&lt;/h2&gt;
&lt;p&gt;This chapter alone covers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CS fundamentals&lt;/li&gt;
&lt;li&gt;LeetCode readiness&lt;/li&gt;
&lt;li&gt;AI mathematical intuition&lt;/li&gt;
&lt;li&gt;Clean software design&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Youâ€™re officially dangerous now ğŸ˜„ğŸ”¥&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CS101-LC04 â€” LeetCode Practice ğŸ§ª</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-leetcode-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-leetcode-tests/</guid>
      <description>&lt;h2 id=&#34;-lc-test-01-sorting&#34;&gt;ğŸ§© LC-TEST-01 Sorting&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: Sort an integer array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[3,1,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Solution (Python)&lt;/summary&gt;
  &lt;p&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_array(nums):
    return sorted(nums)  # Timsort: O(n log n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-lc-test-02-prime-number&#34;&gt;ğŸ§® LC-TEST-02 Prime Number&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: Check if n is prime.&lt;/p&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Solution&lt;/summary&gt;
  &lt;p&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def is_prime(n):
    if n &amp;lt;= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-lc-test-03-candy-greedy&#34;&gt;ğŸ¬ LC-TEST-03 Candy (Greedy)&lt;/h2&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Idea&lt;/summary&gt;
  &lt;p&gt;Use two passes (left â†’ right, right â†’ left)&lt;/p&gt;
&lt;/details&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-01 â€” Sorting an Array</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-01-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-01-sorting/</guid>
      <description>&lt;h2 id=&#34;-problem-statement&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt;, return the array sorted in &lt;strong&gt;ascending order&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This problem looks simple, but interviewers often use it to evaluate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your understanding of &lt;strong&gt;algorithmic trade-offs&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Your knowledge of &lt;strong&gt;time vs space complexity&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Whether you know &lt;strong&gt;when NOT to use built-in functions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sample-input---output&#34;&gt;ğŸ“¥ Sample Input / ğŸ“¤ Output&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Input&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[3, 1, 2]&lt;/td&gt;
&lt;td&gt;[1, 2, 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[5, 4, 3, 2, 1]&lt;/td&gt;
&lt;td&gt;[1, 2, 3, 4, 5]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[2, 2, 1]&lt;/td&gt;
&lt;td&gt;[1, 2, 2]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interviewer-insight-read-this-first&#34;&gt;ğŸ§  Interviewer Insight (Read This First)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;â— &lt;strong&gt;Important:&lt;/strong&gt;&lt;br&gt;
In real interviews, the question is &lt;strong&gt;not&lt;/strong&gt; â€œCan you sort an array?â€&lt;br&gt;
It is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Which sorting algorithm do you choose?&lt;/li&gt;
&lt;li&gt;Why is it optimal &lt;strong&gt;for this scenario&lt;/strong&gt;?&lt;/li&gt;
&lt;li&gt;What are the time &amp;amp; space trade-offs?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Below we show &lt;strong&gt;all major sorting algorithms&lt;/strong&gt; with &lt;strong&gt;clear intuition&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-1--python-built-in-sort-recommended-in-practice&#34;&gt;âœ… Approach 1 â€” Python Built-in Sort (Recommended in Practice)&lt;/h2&gt;
&lt;h3 id=&#34;-idea&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Python uses &lt;strong&gt;Timsort&lt;/strong&gt;, a hybrid of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Merge Sort&lt;/li&gt;
&lt;li&gt;Insertion Sort&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stable&lt;/li&gt;
&lt;li&gt;Extremely fast in real-world data&lt;/li&gt;
&lt;li&gt;Optimized for partially sorted arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-code&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sort_array(nums):
    # Python&#39;s built-in sort uses Timsort
    return sorted(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ &lt;strong&gt;Use this in interviews unless explicitly forbidden.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-2--bubble-sort-educational-only&#34;&gt;ğŸ§© Approach 2 â€” Bubble Sort (Educational Only)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-1&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Repeatedly swap adjacent elements if they are in the wrong order.&lt;/p&gt;
&lt;p&gt;Think of large numbers &lt;strong&gt;â€œbubbling upâ€&lt;/strong&gt; to the end.&lt;/p&gt;
&lt;h3 id=&#34;-code-1&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bubble_sort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(0, n - i - 1):
            if nums[j] &amp;gt; nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-1&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(nÂ²)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸ”´ Rarely used in practice, but good for teaching basics.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-3--selection-sort&#34;&gt;ğŸ§© Approach 3 â€” Selection Sort&lt;/h2&gt;
&lt;h3 id=&#34;-idea-2&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Repeatedly find the &lt;strong&gt;minimum element&lt;/strong&gt; and move it to the front.&lt;/p&gt;
&lt;h3 id=&#34;-code-2&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def selection_sort(nums):
    n = len(nums)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if nums[j] &amp;lt; nums[min_idx]:
                min_idx = j
        nums[i], nums[min_idx] = nums[min_idx], nums[i]
    return nums
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-2&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(nÂ²)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Simple but inefficient for large data.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-4--insertion-sort&#34;&gt;ğŸ§© Approach 4 â€” Insertion Sort&lt;/h2&gt;
&lt;h3 id=&#34;-idea-3&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Build the sorted array &lt;strong&gt;one element at a time&lt;/strong&gt;, similar to sorting playing cards.&lt;/p&gt;
&lt;p&gt;Very efficient for &lt;strong&gt;nearly sorted arrays&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-3&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def insertion_sort(nums):
    for i in range(1, len(nums)):
        key = nums[i]
        j = i - 1
        while j &amp;gt;= 0 and nums[j] &amp;gt; key:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = key
    return nums
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-3&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(nÂ²) worst case, &lt;strong&gt;O(n)&lt;/strong&gt; best case&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Excellent when data is almost sorted.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-5--merge-sort-divide--conquer&#34;&gt;ğŸ§© Approach 5 â€” Merge Sort (Divide &amp;amp; Conquer)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-4&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Divide the array into halves&lt;/li&gt;
&lt;li&gt;Sort each half&lt;/li&gt;
&lt;li&gt;Merge them back together&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-code-4&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def merge_sort(nums):
    if len(nums) &amp;lt;= 1:
        return nums

    mid = len(nums) // 2
    left = merge_sort(nums[:mid])
    right = merge_sort(nums[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i &amp;lt; len(left) and j &amp;lt; len(right):
        if left[i] &amp;lt; right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-4&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Very popular in interviews.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-6--quick-sort-average-fastest&#34;&gt;ğŸ§© Approach 6 â€” Quick Sort (Average Fastest)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-5&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pick a pivot&lt;/li&gt;
&lt;li&gt;Partition elements into smaller &amp;amp; larger&lt;/li&gt;
&lt;li&gt;Recursively sort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-code-5&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quick_sort(nums):
    if len(nums) &amp;lt;= 1:
        return nums

    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x &amp;lt; pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x &amp;gt; pivot]

    return quick_sort(left) + middle + quick_sort(right)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-5&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n log n) average, O(nÂ²) worst&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Very fast in practice, but discuss worst case.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-interview-advice&#34;&gt;ğŸ¯ Final Interview Advice&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Situation&lt;/th&gt;
&lt;th&gt;Best Choice&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Real-world code&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Teaching / basics&lt;/td&gt;
&lt;td&gt;Bubble / Selection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nearly sorted data&lt;/td&gt;
&lt;td&gt;Insertion Sort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Guaranteed performance&lt;/td&gt;
&lt;td&gt;Merge Sort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Average fastest&lt;/td&gt;
&lt;td&gt;Quick Sort&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;ğŸ’¬ &lt;strong&gt;Interview Tip:&lt;/strong&gt;
Always say &lt;em&gt;why&lt;/em&gt; you choose an algorithm, not just &lt;em&gt;how&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway&#34;&gt;ğŸ§  Takeaway&lt;/h2&gt;
&lt;p&gt;Sorting is not about memorizing code.
Itâ€™s about &lt;strong&gt;choosing the right tool for the problem&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This single question can separate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Junior developers&lt;/li&gt;
&lt;li&gt;From &lt;strong&gt;strong algorithmic thinkers&lt;/strong&gt; ğŸš€&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-02 â€” Prime Number Check</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-02-prime-number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-02-prime-number/</guid>
      <description>&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an integer &lt;code&gt;n&lt;/code&gt;, determine whether it is a prime number.&lt;/p&gt;
&lt;h2 id=&#34;sample-input--output&#34;&gt;Sample Input / Output&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Input&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;python-solution&#34;&gt;Python Solution&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def is_prime(n):
    &amp;quot;&amp;quot;&amp;quot;
    Check whether n is a prime number.
    &amp;quot;&amp;quot;&amp;quot;
    if n &amp;lt;= 1:
        return False

    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(âˆšn)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-03 â€” Linear Search</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-03-linear-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-03-linear-search/</guid>
      <description>&lt;h2 id=&#34;-problem-statement&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; and a target value &lt;code&gt;x&lt;/code&gt;, return &lt;code&gt;True&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; exists in the array, otherwise return &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This problem evaluates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your understanding of &lt;strong&gt;search strategies&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Whether you know &lt;strong&gt;when sorted data matters&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Your ability to trade &lt;strong&gt;speed vs constraints&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sample-input---output&#34;&gt;ğŸ“¥ Sample Input / ğŸ“¤ Output&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;nums&lt;/th&gt;
&lt;th&gt;x&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[1, 2, 3]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[1, 2, 3]&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[5]&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[2, 4, 6]&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interviewer-insight&#34;&gt;ğŸ§  Interviewer Insight&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;â— Interviewers are not checking if you can scan an array.&lt;br&gt;
They want to know:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is the array &lt;strong&gt;sorted&lt;/strong&gt;?&lt;/li&gt;
&lt;li&gt;Is random access allowed?&lt;/li&gt;
&lt;li&gt;How large is the data?&lt;/li&gt;
&lt;li&gt;Can preprocessing help?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Below are &lt;strong&gt;all major searching techniques&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-1--linear-search-baseline&#34;&gt;âœ… Approach 1 â€” Linear Search (Baseline)&lt;/h2&gt;
&lt;h3 id=&#34;-idea&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Check every element &lt;strong&gt;one by one&lt;/strong&gt; until the target is found.&lt;/p&gt;
&lt;p&gt;Works on &lt;strong&gt;any array&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(nums, x):
    for v in nums:
        if v == x:
            return True
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Use when the array is &lt;strong&gt;unsorted or very small&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-2--binary-search-sorted-array-required&#34;&gt;ğŸ§© Approach 2 â€” Binary Search (Sorted Array Required)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-1&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Repeatedly divide the search space in half.&lt;/p&gt;
&lt;p&gt;Requires &lt;strong&gt;sorted input&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-1&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(nums, x):
    left, right = 0, len(nums) - 1

    while left &amp;lt;= right:
        mid = (left + right) // 2

        if nums[mid] == x:
            return True
        elif nums[mid] &amp;lt; x:
            left = mid + 1
        else:
            right = mid - 1

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-1&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ One of the &lt;strong&gt;most important interview algorithms&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-3--binary-search-recursive&#34;&gt;ğŸ§© Approach 3 â€” Binary Search (Recursive)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-2&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Same logic as iterative binary search, implemented recursively.&lt;/p&gt;
&lt;h3 id=&#34;-code-2&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search_recursive(nums, x, left, right):
    if left &amp;gt; right:
        return False

    mid = (left + right) // 2

    if nums[mid] == x:
        return True
    elif nums[mid] &amp;lt; x:
        return binary_search_recursive(nums, x, mid + 1, right)
    else:
        return binary_search_recursive(nums, x, left, mid - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-2&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(log n) (recursion stack)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Use only if recursion is preferred.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-4--jump-search-sorted-array&#34;&gt;ğŸ§© Approach 4 â€” Jump Search (Sorted Array)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-3&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Jump ahead by fixed steps (âˆšn) instead of checking every element.&lt;/p&gt;
&lt;p&gt;Useful when &lt;strong&gt;random access is costly&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-3&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math

def jump_search(nums, x):
    n = len(nums)
    step = int(math.sqrt(n))
    prev = 0

    while prev &amp;lt; n and nums[min(step, n) - 1] &amp;lt; x:
        prev = step
        step += int(math.sqrt(n))
        if prev &amp;gt;= n:
            return False

    for i in range(prev, min(step, n)):
        if nums[i] == x:
            return True

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-3&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(âˆšn)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Rare, but good for algorithm discussions.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-5--exponential-search&#34;&gt;ğŸ§© Approach 5 â€” Exponential Search&lt;/h2&gt;
&lt;h3 id=&#34;-idea-4&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Find range where target may exist&lt;/li&gt;
&lt;li&gt;Apply binary search inside that range&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Efficient for &lt;strong&gt;unbounded or infinite arrays&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-4&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def exponential_search(nums, x):
    if not nums:
        return False

    if nums[0] == x:
        return True

    i = 1
    while i &amp;lt; len(nums) and nums[i] &amp;lt;= x:
        i *= 2

    return binary_search(nums[:i], x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-4&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Common in system-level interviews.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-6--hash-set-search-fast-lookup&#34;&gt;ğŸ§© Approach 6 â€” Hash Set Search (Fast Lookup)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-5&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Convert the array into a set for &lt;strong&gt;O(1) average lookup&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-5&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hash_search(nums, x):
    lookup = set(nums)
    return x in lookup
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-5&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n) preprocessing, O(1) lookup&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Excellent when &lt;strong&gt;many searches&lt;/strong&gt; are needed.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-choosing-the-right-search-algorithm&#34;&gt;ğŸ¯ Choosing the Right Search Algorithm&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scenario&lt;/th&gt;
&lt;th&gt;Best Choice&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Unsorted array&lt;/td&gt;
&lt;td&gt;Linear Search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sorted array&lt;/td&gt;
&lt;td&gt;Binary Search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Many queries&lt;/td&gt;
&lt;td&gt;Hash Set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Very large data&lt;/td&gt;
&lt;td&gt;Binary / Exponential&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Teaching fundamentals&lt;/td&gt;
&lt;td&gt;Linear / Binary&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-interview-tip&#34;&gt;ğŸ§  Final Interview Tip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Always ask:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is the data sorted?&lt;/li&gt;
&lt;li&gt;How many queries?&lt;/li&gt;
&lt;li&gt;Is extra memory allowed?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answering these &lt;strong&gt;before coding&lt;/strong&gt; is what impresses interviewers.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;p&gt;Searching is not about speed alone.
Itâ€™s about &lt;strong&gt;choosing the right strategy under constraints&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If you master these, &lt;strong&gt;binary search variations will feel easy&lt;/strong&gt; ğŸš€&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-04 â€” Nested Loops (Thinking Beyond O(nÂ²))</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-04-nested-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-04-nested-loop/</guid>
      <description>&lt;h2 id=&#34;-problem-statement&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt;, determine whether the array contains &lt;strong&gt;any duplicate elements&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Return &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;any value appears at least twice&lt;/strong&gt;, otherwise return &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This problem intentionally encourages a &lt;strong&gt;nested-loop solution first&lt;/strong&gt;, and then tests whether you understand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How nested loops scale&lt;/li&gt;
&lt;li&gt;When they become inefficient&lt;/li&gt;
&lt;li&gt;How to optimize them&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sample-input---output&#34;&gt;ğŸ“¥ Sample Input / ğŸ“¤ Output&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;nums&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[1, 2, 3, 1]&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[1, 2, 3, 4]&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[5]&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[2, 2, 2]&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interviewer-insight&#34;&gt;ğŸ§  Interviewer Insight&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;â— Interviewers &lt;strong&gt;expect&lt;/strong&gt; you to start with a nested loop.&lt;br&gt;
What they really care about is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you analyze the complexity?&lt;/li&gt;
&lt;li&gt;Do you recognize inefficiency?&lt;/li&gt;
&lt;li&gt;Can you improve it?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Letâ€™s start from the &lt;strong&gt;baseline&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-1--brute-force-nested-loop&#34;&gt;ğŸ§© Approach 1 â€” Brute Force Nested Loop&lt;/h2&gt;
&lt;h3 id=&#34;-idea&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Compare &lt;strong&gt;every pair of elements&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If any two elements are equal â†’ duplicate found.&lt;/p&gt;
&lt;h3 id=&#34;-code&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def contains_duplicate(nums):
    n = len(nums)

    # Compare every pair (i, j)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                return True

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(nÂ²)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Correct but &lt;strong&gt;does not scale&lt;/strong&gt; for large input.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-why-nested-loops-are-expensive&#34;&gt;ğŸ” Why Nested Loops Are Expensive&lt;/h2&gt;
&lt;p&gt;If:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n = 1,000 â†’ 1,000,000 comparisons&lt;/li&gt;
&lt;li&gt;n = 10,000 â†’ 100,000,000 comparisons&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ğŸš¨ This is why interviewers worry about nested loops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-2--early-exit-optimization&#34;&gt;ğŸ§© Approach 2 â€” Early Exit Optimization&lt;/h2&gt;
&lt;h3 id=&#34;-idea-1&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Still use nested loops, but &lt;strong&gt;short-circuit early&lt;/strong&gt; when a duplicate is found.&lt;/p&gt;
&lt;h3 id=&#34;-code-1&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def contains_duplicate_early_exit(nums):
    n = len(nums)

    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                # Exit immediately once duplicate is found
                return True

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-1&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(nÂ²) worst case&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Slight improvement, but still quadratic.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-3--nested-loop-with-sorting&#34;&gt;ğŸ§© Approach 3 â€” Nested Loop with Sorting&lt;/h2&gt;
&lt;h3 id=&#34;-idea-2&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;If we &lt;strong&gt;sort first&lt;/strong&gt;, duplicates become adjacent.&lt;/p&gt;
&lt;p&gt;Then we only need &lt;strong&gt;one loop&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;-code-2&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def contains_duplicate_sort(nums):
    nums.sort()

    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1]:
            return True

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-2&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n log n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(1) (ignoring sort internals)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Great improvement â€” shows algorithmic thinking.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-4--hash-set-optimal&#34;&gt;ğŸ§© Approach 4 â€” Hash Set (Optimal)&lt;/h2&gt;
&lt;h3 id=&#34;-idea-3&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Use a set to &lt;strong&gt;remember what we&amp;rsquo;ve seen&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Avoid nested loops entirely.&lt;/p&gt;
&lt;h3 id=&#34;-code-3&#34;&gt;ğŸ§‘â€ğŸ’» Code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def contains_duplicate_hash(nums):
    seen = set()

    for v in nums:
        if v in seen:
            return True
        seen.add(v)

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-3&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space:&lt;/strong&gt; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ This is the &lt;strong&gt;best practical solution&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-nested-loop-pattern-general-form&#34;&gt;ğŸ§  Nested Loop Pattern (General Form)&lt;/h2&gt;
&lt;p&gt;Most nested-loop problems follow this shape:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(n):
    for j in range(i + 1, n):
        # Compare or combine nums[i] and nums[j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pair comparison&lt;/li&gt;
&lt;li&gt;Duplicate detection&lt;/li&gt;
&lt;li&gt;Brute-force two-sum&lt;/li&gt;
&lt;li&gt;Matrix traversal&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-when-nested-loops-are-acceptable&#34;&gt;ğŸ¯ When Nested Loops Are ACCEPTABLE&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scenario&lt;/th&gt;
&lt;th&gt;Acceptable?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;n â‰¤ 1,000&lt;/td&gt;
&lt;td&gt;âœ… Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;One-time computation&lt;/td&gt;
&lt;td&gt;âœ… Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Teaching logic&lt;/td&gt;
&lt;td&gt;âœ… Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Large datasets&lt;/td&gt;
&lt;td&gt;âŒ No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Performance-critical&lt;/td&gt;
&lt;td&gt;âŒ No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interview-level-takeaway&#34;&gt;ğŸ§  Interview-Level Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;â— Nested loops are not â€œbadâ€.
They are &lt;strong&gt;a starting point&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What impresses interviewers is when you say:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;â€œThis works, but itâ€™s O(nÂ²). We can do better.â€&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-advice&#34;&gt;ğŸ Final Advice&lt;/h2&gt;
&lt;p&gt;If you master nested loops:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You understand &lt;strong&gt;brute force&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;You understand &lt;strong&gt;optimization paths&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;You understand &lt;strong&gt;why better algorithms exist&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thatâ€™s the mindset of a &lt;strong&gt;strong programmer&lt;/strong&gt;, not just a coder ğŸš€&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-05 â€” Two Sum (Brute Force â†’ Hash Map)</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-05-two-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-05-two-sum/</guid>
      <description>&lt;h2 id=&#34;-problem-statement&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;target&lt;/code&gt;, return the &lt;strong&gt;indices of two numbers&lt;/strong&gt; such that they add up to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You may assume that &lt;strong&gt;exactly one solution exists&lt;/strong&gt;, and you may not use the same element twice.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sample-input---output&#34;&gt;ğŸ“¥ Sample Input / ğŸ“¤ Output&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;nums&lt;/th&gt;
&lt;th&gt;target&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[2,7,11,15]&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;[0,1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[3,2,4]&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;[1,2]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[3,3]&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;[0,1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[1,5,1,5]&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;[1,3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[-1,-2,-3,-4]&lt;/td&gt;
&lt;td&gt;-6&lt;/td&gt;
&lt;td&gt;[1,3]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interviewer-expectation&#34;&gt;ğŸ§  Interviewer Expectation&lt;/h2&gt;
&lt;p&gt;This problem tests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nested loop thinking&lt;/li&gt;
&lt;li&gt;Optimization awareness&lt;/li&gt;
&lt;li&gt;Hash map mastery&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-1--brute-force-nested-loop&#34;&gt;ğŸ§© Approach 1 â€” Brute Force (Nested Loop)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def two_sum_bruteforce(nums, target):
    n = len(nums)

    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Time: &lt;strong&gt;O(nÂ²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¡ Correct but inefficient.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-approach-2--hash-map-optimal&#34;&gt;ğŸ§© Approach 2 â€” Hash Map (Optimal)&lt;/h2&gt;
&lt;h3 id=&#34;-idea&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Store numbers we have seen and check if &lt;code&gt;target - current&lt;/code&gt; exists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def two_sum(nums, target):
    seen = {}

    for i, v in enumerate(nums):
        complement = target - v

        if complement in seen:
            return [seen[complement], i]

        seen[v] = i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-complexity-1&#34;&gt;â±ï¸ Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Time: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Interview-ready solution.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;â€œUse brute force to understand the problem.
Use hash maps to solve it like a professional.â€&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-matrix-traversal-patterns&#34;&gt;ğŸ“˜ Matrix Traversal Patterns&lt;/h1&gt;
&lt;h2 id=&#34;-problem-statement-1&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given a 2D matrix, traverse it in different patterns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Row-wise&lt;/li&gt;
&lt;li&gt;Column-wise&lt;/li&gt;
&lt;li&gt;Diagonal&lt;/li&gt;
&lt;li&gt;Spiral&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sample-matrix&#34;&gt;ğŸ“¥ Sample Matrix&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;1  2  3
4  5  6
7  8  9
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-row-wise-traversal&#34;&gt;ğŸ§© Row-wise Traversal&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for row in matrix:
    for value in row:
        print(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-column-wise-traversal&#34;&gt;ğŸ§© Column-wise Traversal&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rows, cols = len(matrix), len(matrix[0])

for c in range(cols):
    for r in range(rows):
        print(matrix[r][c])
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-diagonal-traversal&#34;&gt;ğŸ§© Diagonal Traversal&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = len(matrix)

for i in range(n):
    print(matrix[i][i])
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-spiral-traversal-interview-favorite&#34;&gt;ğŸ§© Spiral Traversal (Interview Favorite)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def spiral(matrix):
    res = []
    top, bottom = 0, len(matrix)-1
    left, right = 0, len(matrix[0])-1

    while top &amp;lt;= bottom and left &amp;lt;= right:
        for c in range(left, right+1):
            res.append(matrix[top][c])
        top += 1

        for r in range(top, bottom+1):
            res.append(matrix[r][right])
        right -= 1

        if top &amp;lt;= bottom:
            for c in range(right, left-1, -1):
                res.append(matrix[bottom][c])
            bottom -= 1

        if left &amp;lt;= right:
            for r in range(bottom, top-1, -1):
                res.append(matrix[r][left])
            left += 1

    return res
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-complexity-2&#34;&gt;â±ï¸ Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: &lt;strong&gt;O(m Ã— n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space: &lt;strong&gt;O(1)&lt;/strong&gt; (excluding output)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-1&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;p&gt;Matrix traversal shows &lt;strong&gt;index control mastery&lt;/strong&gt;, critical for vision and AI tasks.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-prefix-sum-killing-nested-loops&#34;&gt;ğŸ“˜ Prefix Sum (Killing Nested Loops)&lt;/h1&gt;
&lt;h2 id=&#34;-problem-statement-2&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt;, answer multiple range sum queries efficiently.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-example&#34;&gt;ğŸ“¥ Example&lt;/h2&gt;
&lt;p&gt;nums = &lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt;&lt;br&gt;
Query sum of range &lt;code&gt;[1,3]&lt;/code&gt; â†’ &lt;code&gt;2 + 3 + 4 = 9&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-brute-force&#34;&gt;ğŸ§© Brute Force&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def range_sum(nums, l, r):
    total = 0
    for i in range(l, r+1):
        total += nums[i]
    return total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ &lt;strong&gt;O(n)&lt;/strong&gt; per query âŒ&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-prefix-sum-optimization&#34;&gt;ğŸ§© Prefix Sum Optimization&lt;/h2&gt;
&lt;h3 id=&#34;-idea-1&#34;&gt;ğŸ’¡ Idea&lt;/h3&gt;
&lt;p&gt;Precompute cumulative sums once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def build_prefix(nums):
    prefix = [0]
    for v in nums:
        prefix.append(prefix[-1] + v)
    return prefix

def range_sum(prefix, l, r):
    return prefix[r+1] - prefix[l]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-complexity-3&#34;&gt;â±ï¸ Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preprocessing: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Query: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ğŸŸ¢ Essential for AI data pipelines.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-2&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;p&gt;Prefix sums turn &lt;strong&gt;nested loops into math&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-sliding-window&#34;&gt;ğŸ“˜ Sliding Window&lt;/h1&gt;
&lt;h2 id=&#34;-problem-statement-3&#34;&gt;ğŸ§© Problem Statement&lt;/h2&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; and integer &lt;code&gt;k&lt;/code&gt;, find the &lt;strong&gt;maximum sum of any subarray of size k&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-example-1&#34;&gt;ğŸ“¥ Example&lt;/h2&gt;
&lt;p&gt;nums = &lt;code&gt;[2,1,5,1,3,2]&lt;/code&gt;, k = 3&lt;br&gt;
Output â†’ &lt;code&gt;9&lt;/code&gt; (&lt;code&gt;[5,1,3]&lt;/code&gt;)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-brute-force-1&#34;&gt;ğŸ§© Brute Force&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def max_sum(nums, k):
    max_sum = 0
    for i in range(len(nums) - k + 1):
        max_sum = max(max_sum, sum(nums[i:i+k]))
    return max_sum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ &lt;strong&gt;O(nk)&lt;/strong&gt; âŒ&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-sliding-window-optimization&#34;&gt;ğŸ§© Sliding Window Optimization&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def max_sum(nums, k):
    window_sum = sum(nums[:k])
    max_sum = window_sum

    for i in range(k, len(nums)):
        window_sum += nums[i]
        window_sum -= nums[i-k]
        max_sum = max(max_sum, window_sum)

    return max_sum
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-complexity-4&#34;&gt;â±ï¸ Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-3&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;p&gt;Sliding window is &lt;strong&gt;mandatory knowledge&lt;/strong&gt; for interviews.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-linear-algebra-for-ai-vectors--matrices&#34;&gt;ğŸ“˜ Linear Algebra for AI (Vectors &amp;amp; Matrices)&lt;/h1&gt;
&lt;h2 id=&#34;-why-linear-algebra-matters&#34;&gt;ğŸ¯ Why Linear Algebra Matters&lt;/h2&gt;
&lt;p&gt;Linear algebra is the &lt;strong&gt;language of AI&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Neural networks&lt;/li&gt;
&lt;li&gt;Embeddings&lt;/li&gt;
&lt;li&gt;Transformers&lt;/li&gt;
&lt;li&gt;Computer vision&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-vectors&#34;&gt;ğŸ§® Vectors&lt;/h2&gt;
&lt;p&gt;A vector represents &lt;strong&gt;features&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-vector-addition&#34;&gt;â• Vector Addition&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(a, b):
    return [a[i] + b[i] for i in range(len(a))]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(n)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-dot-product-core-of-neural-networks&#34;&gt;âœ–ï¸ Dot Product (Core of Neural Networks)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dot(a, b):
    return sum(a[i] * b[i] for i in range(len(a)))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-matrices&#34;&gt;ğŸ§± Matrices&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A = [
    [1, 2],
    [3, 4]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-matrix-multiplication&#34;&gt;âœ–ï¸ Matrix Multiplication&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def matmul(A, B):
    res = [[0]*len(B[0]) for _ in range(len(A))]

    for i in range(len(A)):
        for j in range(len(B[0])):
            for k in range(len(B)):
                res[i][j] += A[i][k] * B[k][j]

    return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ &lt;strong&gt;O(nÂ³)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-ai-interpretation&#34;&gt;ğŸ§  AI Interpretation&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Math&lt;/th&gt;
&lt;th&gt;AI Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Vector&lt;/td&gt;
&lt;td&gt;Feature embedding&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dot product&lt;/td&gt;
&lt;td&gt;Similarity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Matrix&lt;/td&gt;
&lt;td&gt;Layer weights&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MatMul&lt;/td&gt;
&lt;td&gt;Forward pass&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-final-thought&#34;&gt;ğŸ Final Thought&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;If algorithms are &lt;strong&gt;logic&lt;/strong&gt;,
linear algebra is &lt;strong&gt;meaning&lt;/strong&gt; in AI.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LC-TEST-06 â€” Probability for Machine Learning</title>
      <link>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-06-probability-ai/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kaopanboonyuen.github.io/courses/2025-12-30-leetcode-interview-foundations/cs101-lc04-06-probability-ai/</guid>
      <description>&lt;h2 id=&#34;-why-probability-matters&#34;&gt;ğŸ¯ Why Probability Matters&lt;/h2&gt;
&lt;p&gt;Probability is everywhere in AI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model uncertainty&lt;/li&gt;
&lt;li&gt;Classification confidence&lt;/li&gt;
&lt;li&gt;Loss functions&lt;/li&gt;
&lt;li&gt;Bayesian thinking&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interviewers want &lt;strong&gt;intuition&lt;/strong&gt;, not formulas only.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-basic-definitions&#34;&gt;ğŸ§® Basic Definitions&lt;/h2&gt;
&lt;h3 id=&#34;probability&#34;&gt;Probability&lt;/h3&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;P(head) = 1 / 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-conditional-probability&#34;&gt;ğŸ² Conditional Probability&lt;/h2&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given it rains, whatâ€™s the chance traffic is heavy?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-independence&#34;&gt;ğŸ” Independence&lt;/h2&gt;
&lt;p&gt;Two events are independent if:
[
P(A \cap B) = P(A)P(B)
]&lt;/p&gt;
&lt;p&gt;Interview trick question âš ï¸
ğŸ‘‰ Independence â‰  no correlation always&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-bayes-theorem-very-important&#34;&gt;ğŸ§  Bayesâ€™ Theorem (VERY IMPORTANT)&lt;/h2&gt;
&lt;p&gt;Used in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spam detection&lt;/li&gt;
&lt;li&gt;Medical diagnosis&lt;/li&gt;
&lt;li&gt;Bayesian ML&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interview-question&#34;&gt;ğŸ§ª Interview Question&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Why Naive Bayes works despite false independence assumptions?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;âœ… Because it reduces variance and scales well.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Probability gives AI &lt;strong&gt;confidence&lt;/strong&gt;, not just predictions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-gradient-descent-interview-intuition&#34;&gt;ğŸ“˜ Gradient Descent (Interview Intuition)&lt;/h1&gt;
&lt;h2 id=&#34;-problem&#34;&gt;ğŸ¯ Problem&lt;/h2&gt;
&lt;p&gt;How do machines &lt;strong&gt;learn&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;By minimizing a loss function.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-loss-function&#34;&gt;ğŸ“‰ Loss Function&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-gradient-descent-idea&#34;&gt;ğŸ§  Gradient Descent Idea&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Walk downhill in the direction of &lt;strong&gt;steepest descent&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-python-example&#34;&gt;ğŸ§‘â€ğŸ’» Python Example&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gradient_descent(w, x, y, lr=0.01):
    grad = -2 * x * (y - w * x)
    return w - lr * grad
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-variants-interviewers-love&#34;&gt;â±ï¸ Variants Interviewers Love&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Idea&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Batch GD&lt;/td&gt;
&lt;td&gt;Use all data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SGD&lt;/td&gt;
&lt;td&gt;One sample&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mini-batch&lt;/td&gt;
&lt;td&gt;Best of both&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interview-trap&#34;&gt;ğŸš¨ Interview Trap&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Why not use a large learning rate?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;âŒ Overshooting
âŒ Divergence&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-1&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Optimization is the &lt;strong&gt;engine&lt;/strong&gt; of AI.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-numpy-for-coding-interviews&#34;&gt;ğŸ“˜ NumPy for Coding Interviews&lt;/h1&gt;
&lt;h2 id=&#34;-why-numpy&#34;&gt;ğŸ¯ Why NumPy?&lt;/h2&gt;
&lt;p&gt;Interviewers expect:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vectorized thinking&lt;/li&gt;
&lt;li&gt;Clean math code&lt;/li&gt;
&lt;li&gt;Speed awareness&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-arrays-vs-lists&#34;&gt;ğŸ§® Arrays vs Lists&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

a = np.array([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why better?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Faster&lt;/li&gt;
&lt;li&gt;Cleaner&lt;/li&gt;
&lt;li&gt;Mathematical&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-vector-operations&#34;&gt;â• Vector Operations&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a + b        # element-wise
a * b
np.dot(a,b) # dot product
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-matrix-multiplication&#34;&gt;ğŸ§± Matrix Multiplication&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A @ B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.matmul(A, B)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-broadcasting-interview-favorite&#34;&gt;ğŸ“ Broadcasting (Interview Favorite)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adds 1 to every element.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-2&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;NumPy replaces &lt;strong&gt;loops with math&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
---

# Time vs Space Trade-offs

## ğŸ¯ Interview Core Concept

You can optimize:
- Time
- Space

Rarely both.

---

## ğŸ§© Example: Duplicate Detection

### Less Space, More Time

```python
for i in range(n):
    for j in range(i+1, n):
        if nums[i] == nums[j]:
            return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(nÂ²), ğŸ’¾ O(1)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;more-space-less-time&#34;&gt;More Space, Less Time&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;seen = set()
for v in nums:
    if v in seen:
        return True
    seen.add(v)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;â±ï¸ O(n), ğŸ’¾ O(n)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-interview-question-1&#34;&gt;ğŸ§  Interview Question&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Which would you choose?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Correct answer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Depends on constraints.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-takeaway-3&#34;&gt;ğŸ Takeaway&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Strong engineers trade &lt;strong&gt;resources intentionally&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
